특정 기간동안 대여 가능한 자동차들의 대여비용 구하기

SELECT DISTINCT C.CAR_ID, C.CAR_TYPE, ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30) AS FEE
FROM CAR_RENTAL_COMPANY_CAR AS C
    JOIN (SELECT * FROM CAR_RENTAL_COMPANY_DISCOUNT_PLAN WHERE DURATION_TYPE = '30일 이상') AS P
    ON P.CAR_TYPE = C.CAR_TYPE
    LEFT JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY AS H
    ON C.CAR_ID = H.CAR_ID
WHERE C.CAR_TYPE IN ('세단','SUV')
    AND C.CAR_ID
        NOT IN (SELECT CAR_ID FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY WHERE START_DATE <= '2022-11-01' AND END_DATE >= '2022-11-01')
    AND (ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30) >= 500000 AND ROUND(DAILY_FEE * (1 - DISCOUNT_RATE/100) * 30 < 2000000))
ORDER BY FEE DESC, C.CAR_TYPE, C.CAR_ID DESC;


자동차 대여 기록 별 대여 금액 구하기

SELECT H.HISTORY_ID, ROUND(C.DAILY_FEE * (DATEDIFF(H.END_DATE, H.START_DATE) + 1) * (1 - IFNULL(D.DISCOUNT_RATE, 0)/100)) AS FEE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY AS H
    LEFT JOIN CAR_RENTAL_COMPANY_CAR AS C ON C.CAR_ID = H.CAR_ID
    LEFT JOIN CAR_RENTAL_COMPANY_DISCOUNT_PLAN AS D ON C.CAR_TYPE = D.CAR_TYPE AND
      D.DURATION_TYPE = (CASE
                       WHEN DATEDIFF(H.END_DATE, H.START_DATE) + 1 BETWEEN 7 AND 29 THEN "7일 이상"
                       WHEN DATEDIFF(H.END_DATE, H.START_DATE) + 1 BETWEEN 30 AND 89 THEN "30일 이상"
                       WHEN DATEDIFF(H.END_DATE, H.START_DATE) + 1 >= 90 THEN "90일 이상"
                       ELSE "" END)
WHERE C.CAR_TYPE = "트럭"
ORDER BY FEE DESC, H.HISTORY_ID DESC


저자 별 카테고리 별 매출액 집계하기

SELECT A.AUTHOR_ID, A.AUTHOR_NAME, B.CATEGORY, SUM(S.SALES * B.PRICE) AS TOTAL_SALES
FROM BOOK AS B
    JOIN AUTHOR AS A ON B.AUTHOR_ID = A.AUTHOR_ID
    JOIN BOOK_SALES AS S ON B.BOOK_ID = S.BOOK_ID
WHERE DATE_FORMAT(S.SALES_DATE, '%Y-%m') = '2022-01'
GROUP BY A.AUTHOR_NAME, B.CATEGORY
ORDER BY A.AUTHOR_ID ASC, B.CATEGORY DESC


주문량이 많은 아이스크림들 조회하기

SELECT FLAVOR
FROM (SELECT * FROM FIRST_HALF UNION SELECT * FROM JULY) AS YEAR
GROUP BY FLAVOR
ORDER BY SUM(TOTAL_ORDER) DESC
LIMIT 3


취소되지 않은 진료 예약 조회하기

SELECT A.APNT_NO, P.PT_NAME, P.PT_NO, A.MCDP_CD, D.DR_NAME, A.APNT_YMD
FROM PATIENT AS P
    JOIN APPOINTMENT AS A ON P.PT_NO = A.PT_NO
    JOIN DOCTOR AS D ON A.MDDR_ID = D.DR_ID
WHERE DATE_FORMAT(A.APNT_YMD, '%Y-%m-%d') = '2022-04-13'
    AND A.MCDP_CD = 'CS'
    AND A.APNT_CNCL_YN = 'N'
ORDER BY A.APNT_YMD ASC


오프라인/온라인 판매 데이터 통합하기

SELECT SALES_DATE, PRODUCT_ID, USER_ID AS USER_ID, SALES_AMOUNT
FROM (SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, PRODUCT_ID, USER_ID, SALES_AMOUNT FROM ONLINE_SALE
     UNION ALL SELECT DATE_FORMAT(SALES_DATE, '%Y-%m-%d') AS SALES_DATE, PRODUCT_ID, NULL AS USER_ID, SALES_AMOUNT FROM OFFLINE_SALE) AS TOTAL_SALE
WHERE DATE_FORMAT(SALES_DATE, '%Y-%m') = '2022-03'
ORDER BY SALES_DATE ASC, PRODUCT_ID ASC, USER_ID ASC


년, 월, 성별 별 상품 구매 회원 수 구하기

SELECT YEAR(O.SALES_DATE) AS YEAR, MONTH(O.SALES_DATE) AS MONTH, U.GENDER, COUNT(DISTINCT O.USER_ID) AS USERS
FROM USER_INFO AS U JOIN ONLINE_SALE AS O ON U.USER_ID = O.USER_ID
WHERE U.GENDER IS NOT NULL
GROUP BY YEAR(O.SALES_DATE), MONTH(O.SALES_DATE), U.GENDER
ORDER BY YEAR ASC, MONTH ASC, U.GENDER ASC


그룹별 조건에 맞는 식당 목록 출력하기

SELECT M.MEMBER_NAME, R.REVIEW_TEXT, DATE_FORMAT(R.REVIEW_DATE, '%Y-%m-%d') AS REVIEW_DATE
FROM MEMBER_PROFILE AS M JOIN REST_REVIEW AS R ON M.MEMBER_ID = R.MEMBER_ID
WHERE R.MEMBER_ID = (SELECT MEMBER_ID FROM REST_REVIEW
                     GROUP BY MEMBER_ID
                     ORDER BY COUNT(MEMBER_ID) DESC
                     LIMIT 1)
ORDER BY R.REVIEW_DATE ASC, R.REVIEW_TEXT ASC


서울에 위치한 식당 목록 출력하기

SELECT I.REST_ID, I.REST_NAME, I.FOOD_TYPE, I.FAVORITES, I.ADDRESS,
    ROUND(AVG(R.REVIEW_SCORE), 2) AS SCORE
FROM REST_INFO AS I JOIN REST_REVIEW AS R ON I.REST_ID = R.REST_ID
WHERE I.ADDRESS LIKE '서울%'
GROUP BY R.REST_ID
ORDER BY SCORE DESC, I.FAVORITES DESC


5월 식품들의 총매출 조회하기

SELECT P.PRODUCT_ID, P.PRODUCT_NAME, SUM(P.PRICE * O.AMOUNT) AS TOTAL_SALES
FROM FOOD_PRODUCT AS P JOIN FOOD_ORDER AS O ON P.PRODUCT_ID = O.PRODUCT_ID
WHERE DATE_FORMAT(O.PRODUCE_DATE, '%Y-%m') = '2022-05'
GROUP BY O.PRODUCT_ID
ORDER BY TOTAL_SALES DESC, O.PRODUCT_ID ASC


5월 식품들의 총매출 조회하기

SELECT P.PRODUCT_ID, P.PRODUCT_NAME, SUM(P.PRICE * O.AMOUNT) AS TOTAL_SALES
FROM FOOD_PRODUCT AS P JOIN FOOD_ORDER AS O ON P.PRODUCT_ID = O.PRODUCT_ID
WHERE DATE_FORMAT(O.PRODUCE_DATE, '%Y-%m') = '2022-05'
GROUP BY O.PRODUCT_ID
ORDER BY TOTAL_SALES DESC, O.PRODUCT_ID ASC


식품분류별 가장 비싼 식품의 정보 조회하기

SELECT CATEGORY, PRICE AS MAX_PRICE, PRODUCT_NAME
FROM FOOD_PRODUCT
WHERE CATEGORY IN ('과자', '국', '김치', '식용유')
    AND (CATEGORY, PRICE) IN (SELECT CATEGORY, MAX(PRICE) FROM FOOD_PRODUCT GROUP BY CATEGORY)
GROUP BY CATEGORY
ORDER BY MAX_PRICE DESC


우유와 요거트가 담긴 장바구니

SELECT CART_ID
FROM (SELECT DISTINCT CART_ID FROM CART_PRODUCTS WHERE NAME = 'Milk'
     UNION ALL SELECT DISTINCT CART_ID FROM CART_PRODUCTS WHERE NAME = 'Yogurt') AS NEW
GROUP BY CART_ID
HAVING COUNT(*) >= 2
ORDER BY CART_ID ASC


입양 시각 구하기(2)

-- WITH RECURSIVE TABLE(OR VIEW) AS (초기 SQL문 UNION ALL 반복할 SQL문)
WITH RECURSIVE HOURS AS (
    SELECT 0 AS NUM 
    UNION ALL
    SELECT NUM + 1 FROM HOURS
    WHERE NUM < 23
)
SELECT H.NUM AS HOUR, COUNT(O.ANIMAL_ID) AS COUNT
FROM ANIMAL_OUTS AS O RIGHT JOIN HOURS AS H ON HOUR(O.DATETIME) = H.NUM
GROUP BY H.NUM
ORDER BY HOUR ASC


보호소에서 중성화한 동물

SELECT O.ANIMAL_ID, O.ANIMAL_TYPE, O.NAME
FROM ANIMAL_INS AS I JOIN ANIMAL_OUTS AS O ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE I.SEX_UPON_INTAKE LIKE 'Intact%' AND (O.SEX_UPON_OUTCOME LIKE 'Spayed%' OR O.SEX_UPON_OUTCOME LIKE 'Neutered%')
ORDER BY O.ANIMAL_ID ASC